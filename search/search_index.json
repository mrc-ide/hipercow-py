{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>hipercow</code>","text":"<p>This is a package for interfacing with the DIDE cluster directly from Python.  It is related to the R package of the same name but with a focus on working with Python or other commandline-based jobs.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation is possible using <code>pip</code>, with</p> <pre><code>pip install hipercow\n</code></pre> <p>If you need to use a prerelease version you can use:</p> <pre><code>pip install git+https://github.com/mrc-ide/hipercow-py\n</code></pre> <p>or to install from a branch use</p> <pre><code>pip install git+https://github.com/mrc-ide/hipercow-py@branch\n</code></pre>"},{"location":"#practical-installation","title":"Practical installation","text":"<p>Installing from <code>pip</code> is just half the fun.  There are three reasonable options that you might want to explore:</p> <p>You have several basic options to install:</p> <ol> <li>Install into a virtual environment along with everything else</li> <li>Install as a standalone tool with <code>pipx</code> so that <code>hipercow</code> is globally available but not part of your project dependencies</li> <li>Install globally with <code>pip</code> (not recommended)</li> </ol>"},{"location":"#into-your-virtual-environment","title":"Into your virtual environment","text":"<p>We assume that you have created a virtual environment with something along the lines of</p> <pre><code>python -m venv env\n. env/bin/activate # or env/Scripts/activate on Windows\n</code></pre> <p>However, if using the DIDE windows cluster you will be on a network share and this might hit some issues with Python's virtual environment support.</p> <p>After this you can run</p> <pre><code>pip install hipercow\n</code></pre> <p>and <code>hipercow</code> will be available in your project packages.</p> <p>This is the required method if using hipercow programmatically; i.e., if you plan on importing hipercow from your Python code.</p>"},{"location":"#with-pipx","title":"With <code>pipx</code>","text":"<p><code>pipx</code> is a tool for installing a Python package that provides a command line interface in a way that is globally accessible to a user, but without interfering with your system python packages or your project python packages.</p> <p>If you have <code>pipx</code> installed you can run</p> <pre><code>pipx install hipercow\n</code></pre> <p>and then you should be able to run</p> <pre><code>hipercow --version\n</code></pre> <p>without error.  If <code>pipx</code> is not found, then you need to install it.  The <code>pipx</code> page lists installation instructions for every platform.  Pay attention to warnings when installing <code>pipx</code> or <code>hipercow</code> with <code>pipx</code> as these list additional commands that you will need to run in order to find <code>hipercow</code>.  This is particularly the case on Windows.</p>"},{"location":"administration/","title":"Administration","text":"<p>This document is only of interest to people developing <code>hipercow</code> and administering the cluster.  If you are a user, none of the commands here are for you.</p>"},{"location":"administration/#making-a-release","title":"Making a release","text":"<ol> <li>Bump the version number using <code>hatch version</code></li> <li>Commit and push to GitHub, merge the PR</li> <li>Create a new release from the release page</li> <li>In \"Choose a tag\" add <code>v1.2.3</code> or whatever your version will be - this is created on publish</li> <li>Add the release number into the \"Release title\"</li> <li>Describe changes (you may want to use the \"Generate release notes\" button)</li> <li>This will trigger the release action</li> <li>In a few minutes the new version is available at its PyPI page and can be installed with <code>pip</code></li> </ol>"},{"location":"administration/#updating-the-bootstrap","title":"Updating the bootstrap","text":"<p>In general, we'll want the bootstrap updated from the released versions of the package from PyPI.  In the R version of the project though, we have found it useful to have the concept of a development bootstrap, and the most flexible installation approach would be from disk.</p> <p>If the version of <code>hipercow</code> is on PyPI, you should be able to run, from anywhere:</p> <pre><code>hipercow dide bootstrap\n</code></pre> <p>which will update the bootstrap libraries for all supported versions, for both windows and linux. For a specific platform, use the <code>--platform</code> argument, or for specific python versions, use as many <code>--python-version</code> tags as you like; currently we are supporting versions from <code>3.10</code> to <code>3.13</code> inclusive.</p> <p>If you want to use the current development sources (this will be more useful once we have the development bootstrap up and running: <code>mrc-6288</code>) you can do</p> <pre><code>hatch build\nhipercow dide bootstrap --force dist/hipercow-0.0.3-py3-none-any.whl\n</code></pre> <p>but replacing the version number (<code>0.0.3</code>) as required.  The <code>--force</code> is required if you are installing the same version number for a second time.</p>"},{"location":"cli/","title":"Commandline interface","text":"<p>The primary way we expect people to interact with <code>hipercow</code> is via the commandline interface.  This page contains the automatically generated reference documentation for this interface; longer explanations are available elsewhere in the documentation.</p>"},{"location":"cli/#hipercow","title":"hipercow","text":"<p>Interact with hipercow.</p> <p>Usage:</p> <pre><code>hipercow [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>bundle: Interact with bundles.</li> <li>create: Commands for task creation.</li> <li>dide: Commands for interacting with the DIDE cluster.</li> <li>driver: Configure drivers.</li> <li>environment: Interact with environments.</li> <li>init: Initialise a new <code>hipercow</code> root.</li> <li>repl: Launch the interactive REPL.</li> <li>task: Create and interact with tasks.</li> </ul>"},{"location":"cli/#hipercow-bundle","title":"hipercow bundle","text":"<p>Interact with bundles.</p> <p>Usage:</p> <pre><code>hipercow bundle [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>delete: Delete a bundle.</li> <li>list: List bundles.</li> <li>status: Get the status of a bundle.</li> </ul>"},{"location":"cli/#hipercow-bundle-delete","title":"hipercow bundle delete","text":"<p>Delete a bundle.</p> <p>Note that this does not delete the tasks in the bundle, just the bundle itself. So you will not be able to use <code>hipercow bundle</code> to manage the ensemble of jobs together, but you will be able to work with the tasks by their individual ids, using <code>hipercow task</code>.</p> <p>Usage:</p> <pre><code>hipercow bundle delete [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-bundle-list","title":"hipercow bundle list","text":"<p>List bundles.</p> <p>Usage:</p> <pre><code>hipercow bundle list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-bundle-status","title":"hipercow bundle status","text":"<p>Get the status of a bundle.</p> <p>This can offer three levels of summary; and we might redesign the output a bit to make this easier to work with, depending on what people actually do with the output.</p> <p>Please don't try and parse the output directly, but let us know what sort of format you might like it in, as we can easily add something like a JSON format output.</p> <p>Usage:</p> <pre><code>hipercow bundle status [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--summary</code> choice (<code>none</code> | <code>group</code> | <code>single</code>) Summarise the statuses <code>none</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-create","title":"hipercow create","text":"<p>Commands for task creation.</p> <p>Usage:</p> <pre><code>hipercow create [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>bulk: Bulk create tasks by substituting into a template.</li> </ul>"},{"location":"cli/#hipercow-create-bulk","title":"hipercow create bulk","text":"<p>Bulk create tasks by substituting into a template.</p> <p>These created tasks will then belong to a \"bundle\"    with a name (either automatically generated, or of your    choosing), that can be managed using <code>hipercow bundle</code></p> <p>The command must contain <code>@</code>-prefixed placeholders such as</p> <pre><code>mycommand --output=path/@{subdir} @action\n</code></pre> <p>which includes the placeholders <code>subdir</code> and <code>action</code>.</p> <p>You can include data to substitute into this template in three ways:</p> <ul> <li> <p>A single <code>--data=filename.csv</code> argument which will read a <code>csv</code> file   of inputs (here it must contain columns <code>subdir</code> and <code>action</code>)</p> </li> <li> <p>Two arguments <code>--data</code> containing:</p> </li> <li>a comma separated set of values (e.g., <code>--data action=a,b,c</code>)</li> <li>a range of values (e.g., <code>--data subdir=0:n</code> or <code>--data     subdir=0..n</code>); the <code>:</code> form is python-like and does not     include the end of the range, while the <code>..</code> is inclusive and     does include <code>n</code></li> <li>in both cases we will compute the outer product of all     <code>--data</code> arguments and submit all combinations of arguments.</li> </ul> <p>Usage:</p> <pre><code>hipercow create bulk [OPTIONS] [CMD]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--data</code> text Data to use in the template <code>Sentinel.UNSET</code> <code>--environment</code> text The environment in which to run the task <code>Sentinel.UNSET</code> <code>--queue</code> text The queue to submit the task to <code>Sentinel.UNSET</code> <code>--name</code> text An optional name for the bundle <code>Sentinel.UNSET</code> <code>--preview</code> boolean Show preview of tasks that would be created, but don't create any <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-dide","title":"hipercow dide","text":"<p>Commands for interacting with the DIDE cluster.</p> <p>Usage:</p> <pre><code>hipercow dide [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>authenticate: Interact with DIDE authentication.</li> <li>check: Check everything is good to use hipercow on the DIDE cluster.</li> </ul>"},{"location":"cli/#hipercow-dide-authenticate","title":"hipercow dide authenticate","text":"<p>Interact with DIDE authentication.</p> <p>The action can be</p> <ul> <li> <p><code>set</code>: Set your username and password (the default)</p> </li> <li> <p><code>check</code>: Check the stored credentials</p> </li> <li> <p><code>clear</code>: Clear any stored credentials</p> </li> </ul> <p>Usage:</p> <pre><code>hipercow dide authenticate [OPTIONS] [ACTION]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-dide-check","title":"hipercow dide check","text":"<p>Check everything is good to use hipercow on the DIDE cluster.</p> <p>Usage:</p> <pre><code>hipercow dide check [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-driver","title":"hipercow driver","text":"<p>Configure drivers.</p> <p>Usage:</p> <pre><code>hipercow driver [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>configure: Add a driver.</li> <li>list: List configured drivers.</li> <li>show: Show configuration for a driver.</li> <li>unconfigure: Unconfigure (remove) a driver.</li> </ul>"},{"location":"cli/#hipercow-driver-configure","title":"hipercow driver configure","text":"<p>Add a driver.</p> <p>This command will initialise a driver.  There are two current drivers, <code>dide-windows</code> and <code>dide-linux</code>, which target jobs onto windows or linux nodes in our DIDE cluster. For example:-</p> <pre><code>hipercow driver configure dide-windows\n</code></pre> <p>If you provide the <code>--python-version</code> flag you can specify the Python version to use, if you want a version that is different to the version of Python that you are using locally.</p> <p>Usage:</p> <pre><code>hipercow driver configure [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--python-version</code> text Python version to use on the cluster <code>Sentinel.UNSET</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-driver-list","title":"hipercow driver list","text":"<p>List configured drivers.</p> <p>Usage:</p> <pre><code>hipercow driver list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-driver-show","title":"hipercow driver show","text":"<p>Show configuration for a driver.</p> <p>Usage:</p> <pre><code>hipercow driver show [OPTIONS] [NAME]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-driver-unconfigure","title":"hipercow driver unconfigure","text":"<p>Unconfigure (remove) a driver.</p> <p>Usage:</p> <pre><code>hipercow driver unconfigure [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-environment","title":"hipercow environment","text":"<p>Interact with environments.</p> <p>Usage:</p> <pre><code>hipercow environment [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>delete: Delete an environment.</li> <li>list: List environments.</li> <li>new: Create a new environment.</li> <li>provision: Provision an environment.</li> </ul>"},{"location":"cli/#hipercow-environment-delete","title":"hipercow environment delete","text":"<p>Delete an environment.</p> <p>Usage:</p> <pre><code>hipercow environment delete [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--name</code> text N/A <code>Sentinel.UNSET</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-environment-list","title":"hipercow environment list","text":"<p>List environments.</p> <p>Usage:</p> <pre><code>hipercow environment list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-environment-new","title":"hipercow environment new","text":"<p>Create a new environment.</p> <p>Note that this does not actually install anything; you will need to use</p> <pre><code>hipercow environment provision\n</code></pre> <p>to do that, after creation.</p> <p>Usage:</p> <pre><code>hipercow environment new [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--name</code> text Name of the environment <code>default</code> <code>--engine</code> text Engine to use <code>pip</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-environment-provision","title":"hipercow environment provision","text":"<p>Provision an environment.</p> <p>This will launch a cluster task that installs the packages you have requested.  You can pass a command to run here, or use the defaults if your project has a well known (and well behaved) environment description.</p> <p>Usage:</p> <pre><code>hipercow environment provision [OPTIONS] [CMD]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--name</code> text Name of the environment to provision <code>default</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-init","title":"hipercow init","text":"<p>Initialise a new <code>hipercow</code> root.</p> <p>Create a new <code>hipercow</code> root at the path <code>path</code>.  This path should be the root directory of your project (e.g., the path containing <code>.git</code>) and we will create a directory <code>hipercow/</code> within that directory.</p> <p>Once initialised, you should configure a driver and environment.</p> <p>The default is to initialise at the current directory, like <code>git</code> would.</p> <p>Usage:</p> <pre><code>hipercow init [OPTIONS] [PATH]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-repl","title":"hipercow repl","text":"<p>Launch the interactive REPL.</p> <p>Running this creates an interactive session where you can send a series of commands to <code>hipercow</code>, with nice autocompletion. Please let us know how you find this.</p> <p>Type <code>:help</code> for help within the REPL.  To quit, type <code>:exit</code> or Ctrl-D.</p> <p>Usage:</p> <pre><code>hipercow repl [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task","title":"hipercow task","text":"<p>Create and interact with tasks.</p> <p>Usage:</p> <pre><code>hipercow task [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <p>Subcommands</p> <ul> <li>create: Create a task.</li> <li>last: List the most recently created task.</li> <li>list: List all tasks.</li> <li>log: Get a task log.</li> <li>recent: List recent tasks.</li> <li>status: Get the status of a task.</li> <li>wait: Wait for a task to complete.</li> </ul>"},{"location":"cli/#hipercow-task-create","title":"hipercow task create","text":"<p>Create a task.</p> <p>Submits a command line task to the cluster (if you have a driver configured).</p> <p>The command can be any shell command, though for complex ones we expect that quoting might become interesting - let us know how you get on.  If your command involves options (beginning with a <code>-</code>) you will need to use <code>--</code> to separate the commands to <code>hipercow</code> from those to your application.  For example</p> <pre><code>hipercow task create -- cowsay -t hello\n</code></pre> <p>which passes the <code>-t</code> argument through to <code>cowsay</code>.  We may remove this requirement in a future version.</p> <p>If you have multiple environments, you can specify the environment to run the task in with <code>--environment</code>.  We validate the presence of this environment at task submission.</p> <p>If you use <code>--wait</code> then we effectively call <code>hipercow task wait</code> on your newly created task.  You can use this to simulate a blocking task create-and-run type loop, but be aware you might wait for a very long time if the cluster is busy.</p> <p>Usage:</p> <pre><code>hipercow task create [OPTIONS] [CMD]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--environment</code> text The environment in which to run the task <code>Sentinel.UNSET</code> <code>--queue</code> text Queue to submit the task to <code>Sentinel.UNSET</code> <code>--wait</code> boolean Wait for the task to complete <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-last","title":"hipercow task last","text":"<p>List the most recently created task.</p> <p>Usage:</p> <pre><code>hipercow task last [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-list","title":"hipercow task list","text":"<p>List all tasks.</p> <p>This is mostly meant for debugging; the task list is not very interesting and it might take a while to find them all.</p> <p>Usage:</p> <pre><code>hipercow task list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--with-status</code> text N/A <code>Sentinel.UNSET</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-log","title":"hipercow task log","text":"<p>Get a task log.</p> <p>If the log does not yet exist, we return nothing.</p> <p>Usage:</p> <pre><code>hipercow task log [OPTIONS] TASK_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--outer</code> boolean Print the outer logs, from the HPC system <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-recent","title":"hipercow task recent","text":"<p>List recent tasks.</p> <p>Usage:</p> <pre><code>hipercow task recent [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--limit</code> integer The maximum number of tasks to list <code>10</code> <code>--rebuild</code> boolean Rebuild the recent task list <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-status","title":"hipercow task status","text":"<p>Get the status of a task.</p> <p>The <code>task_id</code> will be a 32-character hex string.  We print a single status as a result, this might be <code>created</code>, <code>submitted</code>, <code>running</code>, <code>success</code> or <code>failure</code>.  Additional statuses will be added in future as we expand the tool.</p> <p>Usage:</p> <pre><code>hipercow task status [OPTIONS] TASK_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#hipercow-task-wait","title":"hipercow task wait","text":"<p>Wait for a task to complete.</p> <p>Usage:</p> <pre><code>hipercow task wait [OPTIONS] TASK_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--poll</code> float Time to wait between checking on task (in seconds) <code>1</code> <code>--timeout</code> float Time to wait for task before failing <code>Sentinel.UNSET</code> <code>--show-log</code> / <code>--no-show-log</code> boolean Stream logs to the console, if available? <code>True</code> <code>--progress</code> / <code>--no-progress</code> boolean Show a progress spinner while waiting? <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#error-handling","title":"Error handling","text":"<p>If <code>hipercow</code> throws an error, by default only the actual error message is thrown and not the whole stacktrace.  Over time, we will try and make these error messages rich enough that you can debug things comfortably with what is shown on screen.</p> <pre><code>$ hipercow environment new --engine other\nError: Only the 'pip' and 'empty' engines are supported\nFor more information, run with 'HIPERCOW_TRACEBACK=1'\n</code></pre> <p>To get more information you can set the <code>HIPERCOW_TRACEBACK</code> environment variable, either globally (not recommended except for developing <code>hipercow</code>) or locally:</p> <pre><code>$ HIPERCOW_TRACEBACK=1 hipercow environment new --engine other\nError: Only the 'pip' and 'empty' engines are supported\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Traceback (most recent call last) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 /home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py:54 in cli_safe                      \u2502\n\u2502                                                                                                  \u2502\n\u2502    51 # handling.                                                                                \u2502\n\u2502    52 def cli_safe():                                                                            \u2502\n\u2502    53 \u2502   try:                                                                                   \u2502\n\u2502 \u2771  54 \u2502   \u2502   cli()                                                                              \u2502\n\u2502    55 \u2502   except Exception as e:                                                                 \u2502\n\u2502    56 \u2502   \u2502   _handle_error(e)                                                                   \u2502\n\u2502    57                                                                                            \u2502\n\u2502                                                                                                  \u2502\n\u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 locals \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                            \u2502\n\u2502 \u2502 e = Exception(\"Only the 'pip' and 'empty' engines are supported\") \u2502                            \u2502\n\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                            \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:1161 in __call__                                                             \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:1082 in main                                                                 \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:1697 in invoke                                                               \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:1697 in invoke                                                               \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:1443 in invoke                                                               \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-pac \u2502\n\u2502 kages/click/core.py:788 in invoke                                                                \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py:409 in cli_environment_new          \u2502\n\u2502                                                                                                  \u2502\n\u2502   406 \u2502                                                                                          \u2502\n\u2502   407 \u2502   \"\"\"                                                                                    \u2502\n\u2502   408 \u2502   r = root.open_root()                                                                   \u2502\n\u2502 \u2771 409 \u2502   environment_new(r, name, engine)                                                       \u2502\n\u2502   410                                                                                            \u2502\n\u2502   411                                                                                            \u2502\n\u2502   412 @environment.command(                                                                      \u2502\n\u2502                                                                                                  \u2502\n\u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 locals \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                                       \u2502\n\u2502 \u2502 engine = 'other'                                       \u2502                                       \u2502\n\u2502 \u2502   name = 'default'                                     \u2502                                       \u2502\n\u2502 \u2502      r = &lt;hipercow.root.Root object at 0x7ff0d8893770&gt; \u2502                                       \u2502\n\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                       \u2502\n\u2502                                                                                                  \u2502\n\u2502 /home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/environment.py:45 in environment_new       \u2502\n\u2502                                                                                                  \u2502\n\u2502    42 \u2502                                                                                          \u2502\n\u2502    43 \u2502   if engine not in {\"pip\", \"empty\"}:                                                     \u2502\n\u2502    44 \u2502   \u2502   msg = \"Only the 'pip' and 'empty' engines are supported\"                           \u2502\n\u2502 \u2771  45 \u2502   \u2502   raise Exception(msg)                                                               \u2502\n\u2502    46 \u2502                                                                                          \u2502\n\u2502    47 \u2502   print(f\"Creating environment '{name}' using '{engine}'\")                               \u2502\n\u2502    48 \u2502   EnvironmentConfiguration(engine).write(root, name)                                     \u2502\n\u2502                                                                                                  \u2502\n\u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 locals \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e   \u2502\n\u2502 \u2502 engine = 'other'                                                                           \u2502   \u2502\n\u2502 \u2502    msg = \"Only the 'pip' and 'empty' engines are supported\"                                \u2502   \u2502\n\u2502 \u2502   name = 'default'                                                                         \u2502   \u2502\n\u2502 \u2502   path = PosixPath('/home/rfitzjoh/Documents/src/hipercow-py/tmp/hipercow/py/env/default') \u2502   \u2502\n\u2502 \u2502   root = &lt;hipercow.root.Root object at 0x7ff0d8893770&gt;                                     \u2502   \u2502\n\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nException: Only the 'pip' and 'empty' engines are supported\n</code></pre> <p>This uses <code>rich</code>'s <code>print_exception</code> functionality to print somewhat human readable stack-traces and information on local variables.</p> <p>Alternatively you can show the raw Python stack trace with <code>HIPERCOW_RAW_ERROR</code>:</p> <pre><code>$ HIPERCOW_RAW_ERROR=1 hipercow environment new --engine other\nTraceback (most recent call last):\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/bin/hipercow\", line 8, in &lt;module&gt;\n    sys.exit(cli_safe())\n             ~~~~~~~~^^\n  File \"/home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py\", line 56, in cli_safe\n    _handle_error(e)\n    ~~~~~~~~~~~~~^^^\n  File \"/home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py\", line 61, in _handle_error\n    raise e\n  File \"/home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py\", line 54, in cli_safe\n    cli()\n    ~~~^^\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 1161, in __call__\n    return self.main(*args, **kwargs)\n           ~~~~~~~~~^^^^^^^^^^^^^^^^^\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 1082, in main\n    rv = self.invoke(ctx)\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 1697, in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 1697, in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 1443, in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/rfitzjoh/.local/share/hatch/env/virtual/hipercow/qoF7lZeb/hipercow/lib/python3.13/site-packages/click/core.py\", line 788, in invoke\n    return __callback(*args, **kwargs)\n  File \"/home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/cli.py\", line 409, in cli_environment_new\n    environment_new(r, name, engine)\n    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^\n  File \"/home/rfitzjoh/Documents/src/hipercow-py/src/hipercow/environment.py\", line 45, in environment_new\n    raise Exception(msg)\nException: Only the 'pip' and 'empty' engines are supported\n</code></pre> <p>We may ask you to do one of these if reporting an issue.</p>"},{"location":"dide/","title":"DIDE cluster","text":"<p>This page tries to capture information on the most common pain points people hit when first starting out.</p> <p>We support one cluster at present (the so-called windows cluster) but will support more in future; in particular we aim to support a Linux cluster within DIDE, as well as submission to the the central ICT/RCS cluster. In future we may support others, but we have no immediate plans to.</p> <p>In short, you will need:</p> <ul> <li>to know your DIDE username and password</li> <li>to have been added as a cluster user</li> <li>to be on the DIDE network, probably using ZScaler</li> <li>to be on a network share that the cluster can see</li> </ul> <p>These are all explained in detail below.</p>"},{"location":"dide/#authentication-with-dide","title":"Authentication with DIDE","text":"<p>After installing <code>hipercow</code>, try running</p> <pre><code>hipercow dide authenticate\n</code></pre> <p>which will ask you for your DIDE username and password.</p> <p>If you hit problems, try going to <code>mrcdata.dide.ic.ac.uk/hpc</code> and trying a few combinations until you remember what it should be. Once done update this in your password manager (perhaps BitWarden?) so you can find it easily next time.</p> <p>It is possible that you do not have access to the cluster, even if your username is correct. Try logging onto the portal; if it reports that you don't have access then please request access by messaging Wes. If you don't know your username and password, read on.</p>"},{"location":"dide/#about-our-usernames-and-passwords","title":"About our usernames and passwords","text":"<p>For historical reasons DIDE exists on its own domain (DIDE) separate from Imperial's domain (IC). This means that you may have a different DIDE username to your imperial username (though usually the same) and you may have a different password (though most people set these to be the same).</p> <p>The overall situation is summarised in this infographic:</p> <p></p> <p>If you need to change your DIDE password you can do this from any DIDE domain machine by pressing Ctrl-Alt-Delete and following the prompts. If it has already expired, such that you can't login, you need to contact Chris or Paul.</p> <p>We store credentials using the keyring package.  This saves your username and password securely in your system keyring, which will be unlocked on login for at least Windows and macOS.  You will need to rerun <code>hipercow dide authenticate</code> whenever you change your DIDE password.</p> <p>The username and password that you might have submitted with the R version of hipercow are not currently visible to the Python version, but we hope to address this soon.</p>"},{"location":"dide/#networks","title":"Networks","text":"<p>Ensure you have connected to the DIDE network by using ZScaler; see instructions from ICT, or by being on a desktop PC or virtual machine within the building that is plugged in by Ethernet (this is less common now).</p>"},{"location":"dide/#filesystems-and-paths","title":"Filesystems and paths","text":"<p>For anything to work with <code>hipercow</code> on the DIDE cluster, your working directory must be on a network share.  If you are not sure if you are on a network share, then run</p> <pre><code>pwd\n</code></pre> <p>Interpreting this depends on your platform (the machine you are typing commands into):</p> <ul> <li>Windows: A drive like <code>C:</code> or <code>D:</code> will be local. You should recognise the drive letter as one like <code>Q:</code> that was mapped by default as your home or <code>M:</code> that you mapped yourself as a project share.</li> <li>macOS: The path will likely be below <code>/Volumes</code> (but not one that corresponds to a USB stick of course!)</li> <li>Linux: The path should start at one of the mount points you have configured in <code>/etc/fstab</code> as a network path.</li> </ul>"},{"location":"dide/#project-shares-and-home-directories","title":"Project shares and home directories","text":"<p>In general we strongly recommend that you use project shares for any serious work, rather than your home directory.  To organise these you should talk to your PI (or if you are a PI, talk to Chris).  The advantages of the project shares are that they are larger (so you will run out of disk space more slowly) and faster than the home shares.  If you launch many tasks at once that use your home share you can get unexpected failures as the disk can't keep up with amount of data being read and written.  Don't use your home directory (generally <code>Q:</code> on windows) for anything more intensive than casual experimentation.  We have seen many people with jobs that fail mysteriously on their network home directory when launched in parallel, and this is generally fixed by using a project share.</p> <p>If you don't know if you have a project share, talk to your PI about if one exists. If you are a PI, talk to Chris (and/or Wes) about getting one set up.</p> <p>See below about the current state of the Windows cluster, and some fast storage that you might want to use.</p>"},{"location":"dide/#mapping-network-drives","title":"Mapping network drives","text":"<p>For all operating systems, if you are on the wireless network you will need to connect to the department network using ZScaler; see the ICT documentation for details. If you can get on a wired network you'll likely have a better time because the VPN and wireless network seems less stable in general (it is not clear how this will be in the new building at White City, or indeed how many wired points there will be).</p> <p>Below, instructions for setting up depend on the sort of computer you are typing commands into at the moment (not the cluster type).</p>"},{"location":"dide/#windows","title":"Windows","text":"<p>If you are using a windows machine in the DIDE domain, then your network drives are likely already mapped for you.  In fact you should not even need to map drives as fully qualified network names (e.g. <code>//projects/tmp</code>) should work for you.</p>"},{"location":"dide/#macos","title":"macOS","text":"<p>In Finder, go to <code>Go -&gt; Connect to Server...</code> or press <code>Command-K</code>. In the address field write the name of the share you want to connect to.  You will likely want to mount:</p> <pre><code>smb://qdrive.dide.ic.ac.uk/homes/&lt;username&gt;\n</code></pre> <p>which is your home share.</p> <p>At some point in the process you should get prompted for your username and password, but I can't remember what that looks like.</p> <p>This directory will be mounted at <code>/Volumes/&lt;username&gt;</code> (so the last bit of the filename will be used as the mount point within <code>Volumes</code>).  There may be a better way of doing this, and the connection will not be reestablished automatically so if anyone has a better way let me know.</p>"},{"location":"dide/#linux","title":"Linux","text":"<p>This is what Rich has done on his computer and it seems to work, though it's not incredibly fast.  Full instructions are on the Ubuntu community wiki.</p> <p>First, install <code>cifs-utils</code></p> <pre><code>sudo apt-get install cifs-utils\n</code></pre> <p>In your <code>/etc/fstab</code> file, add</p> <pre><code>//qdrive.dide.ic.ac.uk/homes/&lt;dide-username&gt; &lt;home-mount-point&gt; cifs uid=&lt;local-userid&gt;,gid=&lt;local-groupid&gt;,credentials=/home/&lt;local-username&gt;/.smbcredentials,domain=DIDE,sec=ntlmssp,iocharset=utf8,mfsymlinks 0  0\n</code></pre> <p>where:</p> <ul> <li><code>&lt;dide-username&gt;</code> is your DIDE username without the <code>DIDE\\</code> bit.</li> <li><code>&lt;local-username&gt;</code> is your local username (i.e., <code>echo $USER</code>).</li> <li><code>&lt;local-userid&gt;</code> is your local numeric user id (i.e. <code>id -u $USER</code>)</li> <li><code>&lt;local-groupid&gt;</code> is your local numeric group id (i.e. <code>id -g $USER</code>)</li> <li><code>&lt;home-mount-point&gt;</code> is where you want your DIDE home directory mounted</li> </ul> <p>please back this file up before editing.</p> <p>So for example, I have:</p> <pre><code>//qdrive.dide.ic.ac.uk/homes/rfitzjoh /home/rich/net/home cifs uid=1000,gid=1000,credentials=/home/rich/.smbcredentials,domain=DIDE,sec=ntlmssp,iocharset=utf8 0  0\n</code></pre> <p>The file <code>.smbcredentials</code> contains</p> <pre><code>username=&lt;dide-username&gt;\npassword=&lt;dide-password&gt;\n</code></pre> <p>and set this to be <code>chmod 600</code> for a modicum of security, but be aware your password is stored in plain text.</p> <p>This set up is clearly insecure.  I believe if you omit the credentials line you can have the system prompt you for a password interactively, but I'm not sure how that works with automatic mounting.</p> <p>Finally, run</p> <pre><code>sudo mount -a\n</code></pre> <p>to mount all drives and with any luck it will all work and you don't have to do this until you get a new computer.</p> <p>If you are on a laptop that will not regularly be connected to the internal network, you might want to add the option <code>noauto</code> to the above</p> <pre><code>//qdrive.dide.ic.ac.uk/homes/rfitzjoh /home/rich/net/home cifs uid=1000,gid=1000,credentials=/home/rich/.smbcredentials,domain=DIDE,sec=ntlmssp,iocharset=utf8,noauto,mfsymlinks 0  0\n</code></pre> <p>and then explicitly mount the drive as required with</p> <pre><code>sudo mount ~/net/home\n</code></pre>"},{"location":"dide/#working-on-a-network-share","title":"Working on a network share","text":"<p>The virtual environment you create on your share is different to the one that your jobs will use.  You can install <code>hipercow</code> into this virtual environment:</p> <pre><code>python -m venv env\n. env/bin/activate # or env\\Scripts\\activate on Windows\npip install hipercow\n</code></pre> <p>This might be quite slow in practice, as loading python modules from the network filesystem is a bit painful.</p> <p>Alternatively you could install globally (e.g., with <code>pipx</code>).</p> <p>Sometimes creating a virtual environment on a network share will fail</p> <pre><code>python -m venv env\nError: [Errno 5] Input/output error: 'lib' -&gt; '/home/you/net/home/path/env/lib64\n</code></pre> <p>This should not happen, and does not always, but you can resolve it by disabling use of symlinks:</p> <pre><code>virtualenv --copies env\n</code></pre> <p>It looks like this approach does not work with <code>venv</code> even with <code>--copies</code>.</p> <p>Alternatively (if on Linux), check to see if the <code>mfsymlinks</code> option is in your <code>/etc/fstab</code> entry; this was not included in previous versions of our instructions.  Remount your home directory and try again.</p>"},{"location":"dide/#python-versions","title":"Python versions","text":"<p>By default, we try and run the version of python on the cluster that you are running locally, to the minor version level.  So if you are running any version of 3.13 (e.g., 3.13.2) we will use a version of 3.13 for your jobs.  It is not possible to set the patch version and usually it does not matter.  We'll try and keep the versions on the cluster up to date.</p> <p>You can select the python version that will be run on the cluster by passing <code>--python-version</code> through to <code>hipercow driver configure</code>, for example:</p> <pre><code>hipercow driver configure dide-windows --python-version=3.11\n</code></pre> <p>will use python version 3.11 regardless of what your local version of python is.  This might be useful if you need to run software that depends on an older version of python.</p>"},{"location":"environments/","title":"Environments","text":"<p>We use the term \"environment\" to refer to the context in which a task runs, containing the programs and code it is able to find.  It is not quite the same as the R <code>hipercow</code> concept which considers the execution environment of an R expression, because of the way that Python code is typically run.</p> <p>There are two key sorts of environments we (aim to) support:</p> <ul> <li>Python virtual environments, generally installed via <code>pip</code>.  This is effectively a directory of installed python packages, plus some machinery to set the <code>PATH</code> environment variable (where the operating system looks for programs) and the python search path (<code>sys.path</code>: where Python looks for packages).</li> <li>Conda environments, generally installed by <code>conda</code>, <code>miniconda</code>, <code>mamba</code> or <code>micromamba</code>.  This is a framework popular in bioinformatics and can be used to create a self-consistent installation of a great many tools, isolated from system libraries.</li> </ul> <p>Environments are necessary because we aim to keep globally installed software on the cluster to a minimum.  This reduces the number of times you have to wait for someone else to install or update some piece of software that you depend on for your work.</p>"},{"location":"environments/#in-a-nutshell","title":"In a nutshell","text":"<p>The basic approach for working with environments is:</p> <ol> <li>Tell <code>hipercow</code> the sort of environment you want to work with, and what it is called</li> <li>Install things into that environment (this is launched from your computer but runs on the cluster)</li> <li>Run a task that uses your environment</li> </ol> <pre><code>$ hipercow environment new\n$ hipercow environment provision\n$ hipercow task create mytool\n</code></pre> <p>You must have a driver configured (e.g., by running <code>hipercow driver configure dide</code>) in order to provision an environment.</p>"},{"location":"environments/#default-environments","title":"Default environments","text":"<p>You always have an environment called <code>empty</code>, which contains nothing.  This can run shell commands on the cluster, but without referencing any interesting software.  In the unlikely event that you have a python package that does not need any non-default packages this is all you need.  You cannot install anything else into this environment.</p> <pre><code>$ hipercow environment list\nempty\n</code></pre> <p>You can initialise a more interesting environment using <code>new</code>, this will by default initialise the environment <code>default</code> using the <code>pip</code> engine:</p> <pre><code>$ hipercow environment new\nCreating environment 'default' using 'pip'\n</code></pre>"},{"location":"environments/#provisioning-an-environment-with-pip","title":"Provisioning an environment with <code>pip</code>","text":"<p>To provision an environment, use <code>hipercow environment provision</code>; this runs on the cluster and installs the packages you need to run your tasks.  This is needed because the cluster cannot see the packages you have installed locally, and the cluster nodes might be a different operating system type to your computer anyway.  You can install packages automatically or manually.</p> <p>The automatic installation will get better over time, but we hope this is enough to get at least some people going.  The rules are:</p> <ul> <li>If <code>pyproject.toml</code> exists, we try and install the project using <code>pip install .</code></li> <li>If <code>requirements.txt</code> exists, we try and install from that using <code>pip install -r requirements.txt</code></li> <li>Otherwise we error.</li> </ul> <p>If your project has either <code>pyproject.toml</code> or <code>requirements.txt</code>, hopefully you can just run</p> <pre><code>$ hipercow environment provision\n</code></pre> <p>which will set up the <code>default</code> environment with the packages that you need.</p> <p>There are lots of ways we could improve this in future, for example:</p> <ul> <li>Allow switching the environment from <code>pyproject.toml</code></li> <li>Selection of groups of optional packages to install</li> <li>Multiple installation steps</li> <li>Attempt to install a project in editable mode</li> </ul> <p>Please let us know if you have ideas on how this could be improved.</p> <p>The manual installation is very simple; provide a command that calls <code>pip</code> and we'll run it on the cluster.</p> <p>For example, suppose you need a couple of extra packages:</p> <pre><code>$ hipercow environment provision pip install cowsay fortune-python\n</code></pre> <p>and now both the <code>cowsay</code> and <code>fortune</code> packages (and command line interfaces) are available.</p>"},{"location":"environments/#multiple-environments","title":"Multiple environments","text":"<p>You can have multiple environments configured within a single <code>hipercow</code> root.  This is intended to let you work with a workflow where you need incompatible sets of conda tools, or some jobs with conda and others with pip.  It is not expected that this will be wildly useful to many people and you can generally ignore the existence of this and consider <code>hipercow environment new</code> to be simply the way that you plan on configuring a single environment.</p> <p>You can run</p> <pre><code>$ hipercow environment create --name dev\n</code></pre> <p>to create a new <code>dev</code> environment.  You can provision this the same way as above, but passing <code>--name dev</code> through to <code>provision</code></p> <pre><code>$ hipercow environment provision --name dev pip install &lt;packages...&gt;\n</code></pre> <p>and then when submitting tasks use the <code>--environment</code> option to select the environment:</p> <pre><code>$ hipercow task create --environment dev &lt;your command here&gt;\n</code></pre> <p>Possible use cases of this functionality are:</p> <ul> <li>trying out a different version of a package side-by-side with a previous installation to compare results</li> <li>installing an update without disrupting tasks that are already queued up</li> <li>mixing <code>pip</code>- and <code>conda</code>-based environments in one project (once the latter are supported)</li> </ul>"},{"location":"introduction/","title":"Introduction","text":"<p>This section will describe running a simple task on the cluster, using <code>hipercow</code>.  We make some assumptions, common to the R version:</p> <ul> <li>You are a member of DIDE at Imperial College London</li> <li>You have an account on our cluster; you can check this by logging into the web portal with your DIDE credentials.  If you cannot log in, please email Wes.</li> <li>You are working in a network share that the cluster can see. Ideally this is a project share and not your network home directory, as project shares are much faster and more reliable.  See the DIDE documentation for more on this topic, including how to configure this on your machine</li> <li>You have some Python code that you would like to run on the cluster, which currently works for you locally.</li> <li>You are confident executing commands at the command line (bash or similar). If you are not, please do talk with us as we'd be interested in your workflows.</li> </ul> <p>We also make the assumption that you are OK with some rough edges while we develop this system.  Please be prepared to work with us to track down and understand the bugs that you will definitely run into, so that we can make this tool work for people as well as the R package does.</p>"},{"location":"introduction/#project-layout","title":"Project layout","text":"<p>You may have an existing project, or you might be starting from scratch.  We are not at all prescriptive about how you might structure your files, but we will create a directory <code>hipercow/</code> at the root of your project, and you must not manually change or delete any file within that directory.  It is safe to mix R and Python <code>hipercow</code>s within the same project but at the moment they are completely unaware of each other's existence despite occupying the same space.  It is likely that you will have a <code>pyproject.toml</code> or a <code>requirements.txt</code> file at this level, and quite possibly your <code>.git/</code> directory.</p>"},{"location":"introduction/#interaction-with-hipercow","title":"Interaction with <code>hipercow</code>","text":"<p>If you have installed <code>hipercow</code> successfully, then you will be able to run commands with the <code>hipercow</code> tool; try running</p> <pre><code>$ hipercow --help\nUsage: hipercow [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  dide\n  driver\n  environment\n  init\n  task\n</code></pre>"},{"location":"introduction/#authentication","title":"Authentication","text":"<p>Before starting anything, we should sort out your DIDE credentials.  You need your DIDE username and password - the password might differ from your ICT password, see our guide to passwords.  If unsure, you can check by logging into the web portal.</p> <p>You can run <code>hipercow dide authenticate</code> to store credentials in your system keychain.</p> <pre><code>$ hipercow dide authenticate\n# Please enter your DIDE credentials\n\nWe need to know your DIDE username and password in order to log you into\nthe cluster. This will be shared across all projects on this machine, with\nthe username and password stored securely in your system keychain. You will\nhave to run this command again on other computers\n\nYour DIDE password may differ from your Imperial password, and in some\ncases your username may also differ. If in doubt, perhaps try logging in\nat https://mrcdata.dide.ic.ac.uk/hpc\" and use the combination that works\nfor you there.\n\nDIDE username (default: rfitzjoh) &gt;\nUsing username 'rfitzjoh'\n\nPassword:\nI am going to to try and log in with your password now.\nIf this fails we can always try again\n\nSuccess! I'm saving these into your keyring now so that we can reuse these\nwhen we need to log into the cluster.\n</code></pre> <p>At any point you can check credentials by running</p> <pre><code>$ hipercow dide authenticate check\nFetching credentials\nTesting credentials\nSuccess!\n</code></pre> <p>and you can clear them by running</p> <pre><code>$ hipercow dide authenticate clear\n</code></pre>"},{"location":"introduction/#initialisation","title":"Initialisation","text":"<p>At the root of your project, run:</p> <pre><code>$ hipercow init .\nInitialised hipercow at .\n</code></pre> <p>which creates the <code>hipercow/</code> directory and enables all other commands.</p> <p>Because you will want to submit tasks to the DIDE cluster, we need to configure the <code>dide</code> driver too:</p> <pre><code>$ hipercow driver configure dide-windows\nConfigured hipercow to use 'dide-windows'\n</code></pre>"},{"location":"introduction/#running-hello-world","title":"Running hello world","text":"<p>Tasks are submitted using <code>hipercow task create</code>, followed by any shell command.  In order to make sure that credentials are correct, we recommend submitting a simple task first, like this:</p> <pre><code>$ hipercow task create --wait echo hello hipercow world\na182aa2b169c2e04aa0a5d27fff1acaa\nWaiting......OK\nhello hipercow world\n</code></pre> <p>The <code>--wait</code> option should occur before your command and indicates that <code>hipercow</code> should wait for the task to complete before returning.  The string printed out (<code>a182aa2b169c2e04aa0a5d27fff1acaa</code>) is the \"task id\" - every task gets one of these and they are unique.</p>"},{"location":"introduction/#running-some-python-code","title":"Running some python code","text":"<p>Running python code requires additional steps; we'll need to set an environment for our task to run in, containing any packages that are needed.  If you are in the position where your project does not depend on any packages other than those distributed with python (so no <code>numpy</code>, <code>matplotlib</code>, or anything else) you can skip this step.</p> <p>We need to know what packages you need.  There are a couple of ways of configuring this, though probably the easiest is to write a <code>requirements.txt</code> file suitable to use with <code>pip</code>.  We might have a <code>requirements.txt</code> file that contains simply:</p> <pre><code>cowsay\n</code></pre> <p>indicating that we need that package installed.  Or it could be a bunch of packages and version constraints.</p> <p>The next step is to indicate that we want a <code>pip</code>-based environment; this is the default but this command still needs to be run</p> <pre><code>$ hipercow environment new\nCreating environment 'default' using 'pip'\n</code></pre> <p>Then we need to install our packages on the cluster, so that tasks that we submit find these packages:</p> <pre><code>$ hipercow environment provision\nWaiting...OK\nActual environment location may have moved due to redirects, links or junctions.\n  Requested location: \"Q:\\cluster\\testing\\hipercow\\py\\env\\default\\contents\\venv-windows\\Scripts\\python.exe\"\n  Actual location:    \"\\\\qdrive\\homes\\rfitzjoh\\cluster\\testing\\hipercow\\py\\env\\default\\contents\\venv-windows\\Scripts\\python.exe\"\n\n\n  Obtaining dependency information for cowsay from https://files.pythonhosted.org/packages/f1/13/63c0a02c44024ee16f664e0b36eefeb22d54e93531630bd99e237986f534/cowsay-6.1-py3-none-any.whl.metadata\n  Downloading cowsay-6.1-py3-none-any.whl.metadata (5.6 kB)\nDownloading cowsay-6.1-py3-none-any.whl (25 kB)\nInstalling collected packages: cowsay\n\n\n[notice] A new release of pip is available: 24.3.1 -&gt; 25.0.1\n[notice] To update, run: python.exe -m pip install --upgrade pip\n\n</code></pre> <p>This can take a little while, and we're not really sure why.  And of course a new version of pip is always available.</p> <ul> <li>You will see <code>Waiting</code> followed by dots until <code>OK</code> while the provisioning task queues.</li> <li>The next lines of text are python creating a new empty virtual environment and complaining about paths (this can be ignored)</li> <li>Finally, we see the installation of the <code>cowsay</code> package</li> </ul> <p>Now, we can submit tasks that use the <code>cowsay</code> package:</p> <pre><code>$ hipercow task create --wait -- cowsay -t \"hello hipercow\"\nfdfaa803fc22c9f4e05fd93247358671\nWaiting....OK\n  ______________\n| hello hipercow |\n  ==============\n              \\\n               \\\n                 ^__^\n                 (oo)\\_______\n                 (__)\\       )\\/\\\n                     ||----w |\n                     ||     ||\n</code></pre> <p>The <code>--</code> here in the command is (at least currently) required to separate the command between the bits that relate to <code>hipercow</code> and the bits for your command (here, the <code>-t</code> would make the tool complain).  You also need to use the quotes here around the string to pass to <code>cowsay</code> otherwise this will be interpreted as two arguments and not as the argument to <code>-t</code>.</p> <p>You may not see logs produced with this command due to the gap in time between when the task reports as completed and when it finishes writing to disk (or something like that, we're not sure yet).  But you can get the logs</p> <pre><code>$ hipercow task log fdfaa803fc22c9f4e05fd93247358671\n  ______________\n| hello hipercow |\n  ==============\n              \\\n               \\\n                 ^__^\n                 (oo)\\_______\n                 (__)\\       )\\/\\\n                     ||----w |\n                     ||     ||\n\n</code></pre> <p>and also get the status of the task:</p> <pre><code>$ hipercow task status fdfaa803fc22c9f4e05fd93247358671\nsuccess\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#hipercow.root","title":"<code>hipercow.root</code>","text":"<p>Interact with the hipercow root.</p>"},{"location":"reference/#hipercow.root.OptionalRoot","title":"<code>OptionalRoot = None | str | Path | Root</code>  <code>module-attribute</code>","text":"<p>Optional root type, for user-facing functions.</p> <p>Represents different inputs to the user-facing functions in hipercow, recognising that most of the time the working directory will be within a hipercow environment.  The possible types represent different possibilities:</p> <ul> <li><code>None</code>: search for the root from the current directory (like <code>git</code> does)</li> <li><code>str</code>: the name of a path to search from</li> <li><code>Path</code>: a <code>pathlib.Path</code> object representing the path to search from</li> <li><code>Root</code>: a root previously opened with <code>open_root</code></li> </ul>"},{"location":"reference/#hipercow.root.init","title":"<code>init(path)</code>","text":"<p>Initialise a hipercow root.</p> <p>Sets up a new hipercow root at <code>path</code>, creating the directory <code>&lt;path&gt;/hipercow/</code> which will contain all of hipercow's files.  It is safe to re-initialise an already-created hipercow root (in which case nothing happens) and safe to initialise a Python hipercow root at the same location as an R one, though at the moment they do not interact.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the project root</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.root.open_root","title":"<code>open_root(path=None)</code>","text":"<p>Open a hipercow root.</p> <p>Locate and validate a hipercow root, converting an <code>OptionalRoot</code> type into a real <code>Root</code> object.  This function is used in most user-facing functions in hipercow, but you can call it yourself to validate the root early.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>A path to the root to open, a <code>Root</code>, or <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Root</code>           \u2013            <p>The opened <code>Root</code> object.</p> </li> </ul>"},{"location":"reference/#hipercow.configure","title":"<code>hipercow.configure</code>","text":""},{"location":"reference/#hipercow.configure.configure","title":"<code>configure(name, *, root=None, **kwargs)</code>","text":"<p>Configure a driver.</p> <p>Configures a <code>hipercow</code> root to use a driver.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the driver, <code>dide-windows</code> or <code>dide-linux</code> are the currently provided drivers.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Arguments passed to, and supported by, your driver.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.configure.unconfigure","title":"<code>unconfigure(name, root=None)</code>","text":"<p>Unconfigure (remove) a driver.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the driver.  This will be <code>dide</code> unless you are developing <code>hipercow</code> itself :)</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.task","title":"<code>hipercow.task</code>","text":"<p>Functions for interacting with tasks.</p>"},{"location":"reference/#hipercow.task.TaskStatus","title":"<code>TaskStatus</code>","text":"<p>               Bases: <code>Flag</code></p> <p>Status of a task.</p> <p>Tasks move from <code>CREATED</code> to <code>SUBMITTED</code> to <code>RUNNING</code> to one of <code>SUCCESS</code> or <code>FAILURE</code>.  In addition a task might be <code>CANCELLED</code> (this could happen from <code>CREATED</code>, <code>SUBMITTED</code> or <code>RUNNING</code>) or might be <code>MISSING</code> if it does not exist.</p> <p>A runnable task is one that we could use <code>task_eval</code> with; it might be <code>CREATED</code> or <code>SUBMITTED</code>.</p> <p>A terminal task is one that has reached the latest state it will reach, and is <code>SUCCESS</code>, <code>FAILURE</code> or <code>CANCELLED</code>.</p>"},{"location":"reference/#hipercow.task.TaskStatus.is_runnable","title":"<code>is_runnable()</code>","text":"<p>Check if a status implies a task can be run.</p>"},{"location":"reference/#hipercow.task.TaskStatus.is_terminal","title":"<code>is_terminal()</code>","text":"<p>Check if a status implies a task is completed.</p>"},{"location":"reference/#hipercow.task.task_driver","title":"<code>task_driver(task_id, root)</code>","text":"<p>Get the driver used to submit a task.</p> <p>This may not always be set (e.g., a task was created before a driver was configured), in which case we return <code>None</code>.</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>str</code>)           \u2013            <p>The task identifier to look up.</p> </li> <li> <code>root</code>               (<code>Root</code>)           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>The driver name, if known.  Otherwise <code>None</code>.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_exists","title":"<code>task_exists(task_id, root=None)</code>","text":"<p>Test if a task exists.</p> <p>A task exists if the <code>task_id</code> was used with this hipercow root (i.e., if any files associated with it exist).</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>str</code>)           \u2013            <p>The task identifier, a 32-character hex string.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the task exists.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_last","title":"<code>task_last(root=None)</code>","text":"<p>Return the most recently created task.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> Return <p>A task identifier (a 32-character hex string) if any tasks have been created (and if the recent task list has not been truncated), or <code>None</code> if no tasks have been created.</p>"},{"location":"reference/#hipercow.task.task_list","title":"<code>task_list(*, root=None, with_status=None)</code>","text":"<p>List known tasks.</p> Warning <p>This function could take a long time to execute on large projects with many tasks, particularly on large file systems. Because the tasks are just returned as a list of strings, it may not be terribly useful either.  Think before building a workflow around this.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root to search from.</p> </li> <li> <code>with_status</code>               (<code>TaskStatus | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional status, or set of statuses, to match</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of task identifiers.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_log","title":"<code>task_log(task_id, *, outer=False, root=None)</code>","text":"<p>Read the task log.</p> <p>Not all tasks have logs; tasks that have not yet started (status of <code>CREATED</code> or <code>SUBMITTED</code> and those <code>CANCELLED</code> before starting) will not have logs, and tasks that were run without capturing output will not produce a log either.  Be sure to check if a string was returned.</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>str</code>)           \u2013            <p>The task identifier to fetch the log for, a 32-character hex string.</p> </li> <li> <code>outer</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Fetch the \"outer\" logs; these are logs from the underlying HPC software before it hands off to hipercow.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>The log as a single string, if present.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_recent","title":"<code>task_recent(*, root=None, limit=None)</code>","text":"<p>Return a list of recently created tasks.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of tasks to return.</p> </li> </ul> Return <p>A list of task identifiers.  The most recent tasks will be last in this list (we might change this in a future version - yes, that will be annoying).  Note that this is recency in creation, not completion.</p>"},{"location":"reference/#hipercow.task.task_recent_rebuild","title":"<code>task_recent_rebuild(*, root=None, limit=None)</code>","text":"<p>Rebuild the list of recent tasks.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of tasks to add to the recent list. Use <code>limit=0</code> to truncate the list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_status","title":"<code>task_status(task_id, root=None)</code>","text":"<p>Read task status.</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>str</code>)           \u2013            <p>The task identifier to check, a 32-character hex string.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TaskStatus</code>           \u2013            <p>The status of the task.</p> </li> </ul>"},{"location":"reference/#hipercow.task.task_wait","title":"<code>task_wait(task_id, *, root=None, allow_created=False, **kwargs)</code>","text":"<p>Wait for a task to complete.</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>str</code>)           \u2013            <p>The task to wait on.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> <li> <code>allow_created</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow waiting on a task that has status <code>CREATED</code>.  Normally this is not allowed because a task that is <code>CREATED</code> (and not <code>SUBMITTED</code>) will not start; if you pass <code>allow_created=True</code> it is expected that you are also manually evaluating this task!</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to <code>taskwait.taskwait</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the task completes successfully, <code>False</code> if it</p> </li> <li> <code>bool</code>           \u2013            <p>fails.  A timeout will throw an error.  We return this boolean</p> </li> <li> <code>bool</code>           \u2013            <p>rather than the <code>TaskStatus</code> because this generalises to</p> </li> <li> <code>bool</code>           \u2013            <p>multiple tasks.</p> </li> </ul>"},{"location":"reference/#hipercow.task_create","title":"<code>hipercow.task_create</code>","text":""},{"location":"reference/#hipercow.task_create.task_create_shell","title":"<code>task_create_shell(cmd, *, environment=None, envvars=None, resources=None, driver=None, root=None)</code>","text":"<p>Create a shell command task.</p> <p>This is the first type of task that we support, and more types will likely follow.  A shell command will evaluate an arbitrary command on the cluster - it does not even need to be written in Python! However, if you are using the <code>pip</code> environment engine then it will need to be <code>pip</code>-installable.</p> <p>The interface here is somewhat subject to change, but we think the basics here are reasonable.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to execute, as a list of strings</p> </li> <li> <code>environment</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the environment to evaluate the command in.  The default (<code>None</code>) will select <code>default</code> if available, falling back on <code>empty</code>.</p> </li> <li> <code>envvars</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of environment variables to set before the task runs.  Do not set <code>PATH</code> in here, it will not currently have an effect.</p> </li> <li> <code>resources</code>               (<code>TaskResources | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional resources required by your task.</p> </li> <li> <code>driver</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The driver to launch the task with.  Generally this is not needed as we expect most people to have a single driver set.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The newly-created task identifier, a 32-character hex string.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle","title":"<code>hipercow.bundle</code>","text":"<p>Support for bundles of related tasks.</p>"},{"location":"reference/#hipercow.bundle.Bundle","title":"<code>Bundle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A bundle of tasks.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The bundle name</p> </li> <li> <code>task_ids</code>               (<code>list[str]</code>)           \u2013            <p>The task identifiers in the bundle</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_create","title":"<code>bundle_create(task_ids, name=None, *, validate=True, overwrite=True, root=None)</code>","text":"<p>Create a new bundle from a list of tasks.</p> <p>Parameters:</p> <ul> <li> <code>task_ids</code>               (<code>list[str]</code>)           \u2013            <p>The task identifiers in the bundle</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name for the bundle.  If not given, we randomly create one.  The format of the name is subject to change.</p> </li> <li> <code>validate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that all tasks exist before creating the bundle.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Overwrite a bundle if it already exists.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>The name of the newly created bundle.  Also, as a side</p> <ul> <li> <code>str</code>           \u2013            <p>effect, writes out the task bundle to disk.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_delete","title":"<code>bundle_delete(name, root=None)</code>","text":"<p>Delete a bundle.</p> <p>Note that this does not delete the tasks in the bundle, just the bundle itself.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the bundle to delete</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_list","title":"<code>bundle_list(root=None)</code>","text":"<p>List bundles.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>The names of known bundles.  Currently the order of these</p> <ul> <li> <code>list[str]</code>           \u2013            <p>is arbitrary.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_load","title":"<code>bundle_load(name, root=None)</code>","text":"<p>Load a task bundle.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the bundle to load</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bundle</code>           \u2013            <p>The loaded bundle.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_status","title":"<code>bundle_status(name, root=None)</code>","text":"<p>Get the statuses of tasks in a bundle.</p> <p>Depending on the context, <code>bundle_status_reduce()</code> may be more appropriate function to use, which attempts to reduce the list of statuses into the single \"worst\" status.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the bundle to get the statuses for.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[TaskStatus]</code>           \u2013            <p>A list of statuses, one per task.  These are stored in</p> </li> <li> <code>list[TaskStatus]</code>           \u2013            <p>the same order as the original bundle.</p> </li> </ul>"},{"location":"reference/#hipercow.bundle.bundle_status_reduce","title":"<code>bundle_status_reduce(name, root=None)</code>","text":"<p>Get the overall status from a bundle.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the bundle to get the statuses for.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TaskStatus</code>           \u2013            <p>The overall bundle status.</p> </li> </ul>"},{"location":"reference/#hipercow.environment","title":"<code>hipercow.environment</code>","text":""},{"location":"reference/#hipercow.environment.environment_check","title":"<code>environment_check(name, root=None)</code>","text":"<p>Validate an environment name for this root.</p> <p>This function can be used to ensure that <code>name</code> is a reasonable environment name to use in your root.  It returns the resolved name (selecting between <code>empty</code> and <code>default</code> if <code>name</code> is <code>None</code>), and errors if the requested environment is not found.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the environment to use, or <code>None</code> to select the appropriate default.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The resolved environment name.</p> </li> </ul>"},{"location":"reference/#hipercow.environment.environment_delete","title":"<code>environment_delete(name, root=None)</code>","text":"<p>Delete an environment.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the environment to delete.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.environment.environment_exists","title":"<code>environment_exists(name, root=None)</code>","text":"<p>Check if an environment exists.</p> <p>Note that this function will return <code>False</code> for <code>empty</code>, even though <code>empty</code> is always a valid choice.  We might change this in future.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the environment to check.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the environment exists, otherwise <code>False</code>.</p> </li> </ul>"},{"location":"reference/#hipercow.environment.environment_list","title":"<code>environment_list(root=None)</code>","text":"<p>List known environments.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A sorted list of environment names.  The name <code>empty</code> will always be present.</p> </li> </ul>"},{"location":"reference/#hipercow.environment.environment_new","title":"<code>environment_new(name, engine, root=None)</code>","text":"<p>Create a new environment.</p> <p>Creating an environment selects a name and declares the engine for the environment.  After doing this, you will certainly want to provision the environment using <code>provision()</code>.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name for the environment.  The name <code>default</code> is a good choice if you only want a single environment, as this is the environment used by default.  You cannot use <code>empty</code> as that is a special empty environment.</p> </li> <li> <code>engine</code>               (<code>str</code>)           \u2013            <p>The environment engine to use.  The options here are <code>pip</code> and <code>empty</code>.  Soon we will support <code>conda</code> too.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects.</p> </li> </ul>"},{"location":"reference/#hipercow.provision","title":"<code>hipercow.provision</code>","text":""},{"location":"reference/#hipercow.provision.provision","title":"<code>provision(name, cmd, *, driver=None, root=None)</code>","text":"<p>Provision an environment.</p> <p>This function requires that your root has a driver configured (with <code>hipercow.configure</code>) and an environment created (with <code>hipercow.environment_new</code>).</p> <p>Note that in the commandline tool, this command is grouped into the <code>environment</code> group; we may move this function into the <code>environment</code> module in future.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the environment to provision</p> </li> <li> <code>cmd</code>               (<code>list[str] | None</code>)           \u2013            <p>Optionally the command to run to do the provisioning. If <code>None</code> then the environment engine will select an appropriate command if it is well defined for your setup. The details here depend on the engine.</p> </li> <li> <code>driver</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the driver to use in provisioning. Normally this can be omitted, as <code>None</code> (the default) will select your driver automatically if only one is configured.</p> </li> <li> <code>root</code>               (<code>OptionalRoot</code>, default:                   <code>None</code> )           \u2013            <p>The root, or if not given search from the current directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.resources","title":"<code>hipercow.resources</code>","text":"<p>Specify and interact with resources.</p>"},{"location":"reference/#hipercow.resources.ClusterResources","title":"<code>ClusterResources</code>  <code>dataclass</code>","text":"<p>Resources available on a cluster.</p> <p>This will be returned by a cluster driver and will be used to validate resources.</p> <p>Attributes:</p> <ul> <li> <code>queues</code>               (<code>Queues</code>)           \u2013            <p>Valid queues.</p> </li> <li> <code>max_memory</code>               (<code>int</code>)           \u2013            <p>The maximum ram across all nodes in the cluster.</p> </li> <li> <code>max_cores</code>               (<code>int</code>)           \u2013            <p>The maximum cores across all nodes in the cluster.</p> </li> </ul>"},{"location":"reference/#hipercow.resources.ClusterResources.validate_resources","title":"<code>validate_resources(resources)</code>","text":"<p>Check resources are valid on this cluster.</p> <p>Takes a set of resources and checks that the requested queue, number of cores and ram are valid for the cluster.  If the queue is not provided, then we will take the default.</p> <p>Parameters:</p> <ul> <li> <code>resources</code>               (<code>TaskResources</code>)           \u2013            <p>Resources to validate.</p> </li> </ul>"},{"location":"reference/#hipercow.resources.Queues","title":"<code>Queues</code>  <code>dataclass</code>","text":"<p>Queues available on the cluster.</p> <p>Attributes:</p> <ul> <li> <code>valid</code>               (<code>set[str]</code>)           \u2013            <p>The set of valid queue names. Being a set, the order does not imply anything.</p> </li> <li> <code>default</code>               (<code>str</code>)           \u2013            <p>The default queue, used if none is explicitly given</p> </li> <li> <code>build</code>               (<code>str</code>)           \u2013            <p>The queue used to run build jobs</p> </li> <li> <code>test</code>               (<code>str</code>)           \u2013            <p>The queue used to run test jobs</p> </li> </ul>"},{"location":"reference/#hipercow.resources.Queues.simple","title":"<code>simple(name)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Queues</code> object with only one valid queue.</p> <p>This situation is common enough that we provide a small wrapper.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The only supported queue.  This will become the set of valid queues, the default queue, the build queue and the test queue.</p> </li> </ul>"},{"location":"reference/#hipercow.resources.TaskResources","title":"<code>TaskResources</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Resources required for a task.</p> <p>We don't support everything that the R version does yet; in particular we've not set up <code>hold_until</code>, <code>priority</code> or <code>requested_nodes</code>, as these are not widely used.</p> <p>Attributes:</p> <ul> <li> <code>queue</code>               (<code>str | None</code>)           \u2013            <p>The queue to run on.  If not given (or <code>None</code>), we use the default queue for your cluster.  Alternatively, you can provide <code>.default</code> for the default queue or <code>.test</code> for the test queue.</p> </li> <li> <code>cores</code>               (<code>int | float</code>)           \u2013            <p>The number of cores to request.  Adding more cores does not necessarily make your task any faster; your task must have some mechanism to exploit this parallelism (e.g., using the <code>multiprocessing</code> package).  Specify <code>math.inf</code> if you want to request all the cores on a single node.</p> </li> <li> <code>exclusive</code>               (<code>bool</code>)           \u2013            <p>Request exclusive access to a node.</p> </li> <li> <code>max_runtime</code>               (<code>int | None</code>)           \u2013            <p>The maximum run time (wall clock), in seconds.</p> </li> <li> <code>memory_per_node</code>               (<code>int | None</code>)           \u2013            <p>Specify that your task can only run on a node with at least this much memory, in GB (e.g, 128 is 128GB).</p> </li> <li> <code>memory_per_task</code>               (<code>int | None</code>)           \u2013            <p>An estimate of how much memory your task requires (across all cores), in GB.  If you provide this, the scheduler can attempt to arrange tasks such that they will all fit in the available RAM.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines","title":"<code>hipercow.environment_engines</code>","text":"<p>Support for environment engines.</p>"},{"location":"reference/#hipercow.environment_engines.Empty","title":"<code>Empty</code>","text":"<p>               Bases: <code>EnvironmentEngine</code></p> <p>The empty environment, into which nothing may be installed.</p>"},{"location":"reference/#hipercow.environment_engines.Empty.check_args","title":"<code>check_args(cmd)</code>","text":"<p>Check arguments to the empty environment, which must be empty.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str] | None</code>)           \u2013            <p>A list or <code>None</code>, if the list is not empty an error is thrown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The empty list.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Empty.create","title":"<code>create(**kwargs)</code>","text":"<p>Create the empty environment, which already exists.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Never returns, but throws if called.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Empty.exists","title":"<code>exists()</code>","text":"<p>The empty environment always exists.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code></p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Empty.path","title":"<code>path()</code>","text":"<p>The path to the empty environment, which never exists.</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Never returns, but throws if called.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Empty.provision","title":"<code>provision(cmd, **kwargs)</code>","text":"<p>Install packages into the empty environment, which is not allowed.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Never returns, but throws if called.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine","title":"<code>EnvironmentEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for environment engines.</p> <p>Attributes:</p> <ul> <li> <code>root</code>           \u2013            <p>The <code>hipercow</code> root</p> </li> <li> <code>name</code>           \u2013            <p>The name of the environment to provision</p> </li> <li> <code>platform</code>           \u2013            <p>Optionally, the platform to target.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.check_args","title":"<code>check_args(cmd)</code>  <code>abstractmethod</code>","text":"<p>Check arguments provided in <code>cmd</code> for suitability.</p> <p>This method runs on the client; the python process initiating the provisioning request, and does not run in the context of the process that will create the environment.  In particular, don't assume that the platform information is the same.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str] | None</code>)           \u2013            <p>A list of arguments to provision an environment, or <code>None</code> if the user provided none.  In the latter case you must provide suitable defaults or error.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A validated list of arguments.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.create","title":"<code>create(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Create (or initialise) the environment.</p> <p>This method will be called on the target platform, not on the client platform.  Most environment systems have a concept of initialisation; this will typically create the directory referred to by <code>path()</code>, and do any required bootstrapping. It will not typically install anything for the user.</p> <p>In general, we expect <code>create()</code> to be called only once per environment lifetime, while <code>provision()</code> we expect to be called every time the environment is modified (one or many times).</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed on to the concrete method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Nothing</code> (              <code>None</code> )          \u2013            <p>Called for side-effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.exists","title":"<code>exists()</code>","text":"<p>Test if an environment exists.</p> <p>This method is not abstract, and generally should not need to be replaced by derived classes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the environment directory exists, otherwise</p> </li> <li> <code>bool</code>           \u2013            <p><code>False</code>.  Note that <code>True</code> does not mean that the</p> </li> <li> <code>bool</code>           \u2013            <p>environment is usable; this is mostly intended to be</p> </li> <li> <code>bool</code>           \u2013            <p>used to determine if <code>create()</code> needs to be called.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.path","title":"<code>path()</code>","text":"<p>Compute path to the environment contents.</p> <p>This base method version will return a suitable path within the root.  Implementations can use this path directly (say, if the environment path does not need to differ according to platform etc), or compute their own.  We might change the logic here in future to make this base-class returned path more generally useful.</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>The path to the directory that will store the environment.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.provision","title":"<code>provision(cmd, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Provision an environment.</p> <p>Install packages or software into the environment.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>A command to run in the environment.  Most of the time this just calls <code>hipercow.utils.subprocess_run</code> directly</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed through to the concrete method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Nothing</code> (              <code>None</code> )          \u2013            <p>Called for side-effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.EnvironmentEngine.run","title":"<code>run(cmd, *, env=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Run a command within an environment.</p> <p>Both provisioning and running tasks will run in their context of an environment.  This method must be specialised to activate the environment and then run the given shell command.</p> <p>This method should (eventually) call <code>hipercow.util.subprocess_run</code>, returning the value from that function.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to run</p> </li> <li> <code>env</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional dictionary of environment variables that will be set within the environment.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional methods passed from the provisioner or the task runner.</p> </li> </ul> Return <p>Information about the completed process.  Note that errors are not thrown unless the keyword argument <code>check=True</code> is provided.</p>"},{"location":"reference/#hipercow.environment_engines.Pip","title":"<code>Pip</code>","text":"<p>               Bases: <code>EnvironmentEngine</code></p> <p>Python virtual environments, installed by pip.</p>"},{"location":"reference/#hipercow.environment_engines.Pip.check_args","title":"<code>check_args(cmd)</code>","text":"<p>Validate pip installation command.</p> <p>Checks if <code>cmd</code> is a valid <code>pip</code> command.</p> <p>If <code>cmd</code> is <code>None</code> or the empty list, we try and guess a default command, based on files found in your project root.</p> <ul> <li> <p>if you have a <code>pyproject.toml</code> file, then we will try and   run <code>pip install --verbose .</code></p> </li> <li> <p>if you have a <code>requirements.txt</code>, then we will try and run   <code>pip install --verbose -r requirements.txt</code></p> </li> </ul> <p>(In both cases these are returned as a list of arguments.)</p> <p>If there are other reasonable conventions that we might follow, please let us know.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str] | None</code>)           \u2013            <p>The command to validate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A validated list of arguments.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Pip.create","title":"<code>create(**kwargs)</code>","text":"<p>Create the virtual environment.</p> <p>Calls</p> <pre><code>python -m venv &lt;path&gt;\n</code></pre> <p>with the result of <code>path()</code>.</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to <code>subprocess_run</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Nothing, called for side effects only.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Pip.provision","title":"<code>provision(cmd, **kwargs)</code>","text":"<p>Provision a virtual environment using pip.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to run</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to <code>Pip.run</code></p> </li> </ul> <p>Returns: Nothing, called for its side effect only.</p>"},{"location":"reference/#hipercow.environment_engines.Pip.run","title":"<code>run(cmd, *, env=None, **kwargs)</code>","text":"<p>Run a command within the pip virtual environment.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to run</p> </li> <li> <code>env</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables, passed into <code>subprocess_run</code>. We will add additional environment variables to control the virtual environment activation.  Note that <code>PATH</code> cannot be safely set through <code>env</code> yet, because we have to modify that to activate the virtual environment, and because <code>subprocess.Popen</code> requires the <code>PATH</code> to be set before finding the program to call on Windows.  We may improve this in future.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to <code>subprocess_run</code>.</p> </li> </ul> <p>Details about the process, if `check=True` is not</p> <ul> <li> <code>CompletedProcess</code>           \u2013            <p>present in <code>kwargs</code></p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Platform","title":"<code>Platform</code>  <code>dataclass</code>","text":"<p>Information about a platform.</p> <p>The most basic information about a platform that we need to set up an environment, derived from the the <code>platform</code> module.</p> <p>Attributes:</p> <ul> <li> <code>system</code>               (<code>str</code>)           \u2013            <p>The name of the system, in lowercase.  Values will be <code>linux</code>, <code>windows</code> or <code>darwin</code> (macOS).  We may replace this with an <code>Enum</code> in future.</p> </li> <li> <code>version</code>               (<code>str</code>)           \u2013            <p>The python version, as a 3-element version string.</p> </li> </ul>"},{"location":"reference/#hipercow.environment_engines.Platform.local","title":"<code>local()</code>  <code>staticmethod</code>","text":"<p>Platform information for the running Python.</p> <p>A convenience function to construct suitable platform information for the currently running system.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#for-users-of-the-r-hipercow","title":"For users of the R <code>hipercow</code>","text":"<p>This package will feel quite different to the R version of <code>hipercow</code>; our aim here is to provide a somewhat Pythonic interface to the cluster that takes the best ideas from the R version without directly implementing the same API.  The two packages currently share the same name but do not yet interact directly -- this may change in future as they develop,</p> <p>The most obvious difference at the moment is that all interaction with the python version occurs via the command line interface.  We have started here because it seems far less common to use the REPL from Python than it does in R.  This change has many positives; it makes running arbitrary programs (e.g., python packages with commandline interfaces, bioinformatics tools, etc) very straightforward, so long as they can be found.</p>"},{"location":"roadmap/#missing-features","title":"Missing features","text":"<p>Many of these are features that will feel familiar to users of the R version.</p> <ul> <li>The concept of \"resources\" for a task (e.g., the number of cores etc).  This will likely be added soon.</li> <li>Running functions, or expressions of python code, without writing it out as a file.  This requires thoughts and opinions about interface and we welcome feedback and ideas.</li> <li>Running many related tasks at once and interacting with this bundle.  We do not know what the easiest interface for this looks like and welcome ideas and feedback.</li> <li>The \"worker\" patterns for a faster, less persistent, queue.</li> <li>Review the effect of a series of attempts to install packages</li> <li>Retry failed tasks</li> <li>Support multiple mounted windows shares at once</li> <li>Run on our new Linux cluster</li> <li>Retrieve information about the cluster that you are running on</li> <li>Support for setting up conda environments, particularly to support bioinformatics workflows.</li> </ul> <p>There are also many rough edges:</p> <ul> <li>The way that progress and messages are printed out is spartan at best, and a far cry from our standard use of the <code>cli</code> R package</li> <li>If an error is thrown, you will see a gory stacktrace</li> <li>The provisioning is pretty basic</li> <li>Not all error output makes it from the cluster back to your screen</li> </ul>"},{"location":"tlo/","title":"Using TLO","text":"<p>These instructions are for using the Thanzi la Onse model model on the DIDE cluster with hipercow.  We'll probably update some of the <code>TLOmodel</code> wiki once things stabilise and then we can perhaps point there as a source of truth.</p> <p>The current state of play: We can currently run a simple copy of the model on the cluster, running on Python 3.11 under Windows.  None of the Azure workflows are supported.</p> <p>Minimal instructions, within a clone of <code>TLOmodel</code>.</p> <p>First set up a hipercow root and configure it to use Python 3.11 on the DIDE Windows cluster:</p> <pre><code>hipercow init\nhipercow driver configure dide-windows --python-version=3.11\nhipercow driver show dide-windows\n</code></pre> <p>Install the dependencies and the model itself into a virtual environment on the cluster:</p> <pre><code>hipercow environment new\nhipercow environment provision -- pip install --verbose -r requirements/dev.txt\nhipercow environment provision -- pip install --verbose .\n</code></pre> <p>On the home drive, installation takes 200-300s for the development requirements and and 66s for the package itself.  The requirements installation will appear to pause with no output for quite a while.</p> <p>Optionally, confirm that things work:</p> <pre><code>hipercow task create --wait -- tlo --help\n</code></pre> <p>You can submit tasks with the <code>tlo</code> command to run a scenario.  For example:</p> <pre><code>hipercow task create tlo scenario-run src/scripts/dev/scenarios/cluster-run.py\n</code></pre> <p>After which you can use <code>hipercow task wait</code>, <code>hipercow task log</code> and <code>hipercow task status</code> to keep an eye on your task.  If you have many tasks to submit, you might need to use a loop in bash or similar.</p>"}]}